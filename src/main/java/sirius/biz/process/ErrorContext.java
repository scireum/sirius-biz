/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.biz.process;

import sirius.biz.process.logs.ProcessLog;
import sirius.biz.process.logs.ProcessLogType;
import sirius.kernel.async.CallContext;
import sirius.kernel.async.SubContext;
import sirius.kernel.async.TaskContext;
import sirius.kernel.commons.Producer;
import sirius.kernel.commons.Strings;
import sirius.kernel.commons.UnitOfWork;
import sirius.kernel.health.Exceptions;
import sirius.kernel.health.HandledException;
import sirius.kernel.health.Log;
import sirius.kernel.nls.NLS;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Optional;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;

/**
 * Provides a local context to enhance error messages (mostly within {@link sirius.biz.jobs.batch.BatchJob jobs}).
 * <p>
 * When importing data (especially for complex files like XML), the error messages generated by <tt>sirius-db</tt>
 * are often not concise enough. Therefore, we populate this error context to keep track which entity was modified
 * and which actual action as been attempted.
 */
public class ErrorContext implements SubContext {

    private final Map<String, String> context = new LinkedHashMap<>();

    /**
     * Reveals the context for the current thread.
     *
     * @return the current error context
     */
    public static ErrorContext get() {
        return CallContext.getCurrent().getOrCreateSubContext(ErrorContext.class);
    }

    /**
     * Adds a value to the error context.
     *
     * @param label the name of the value (this will be {@link NLS#smartGet(String) auto translated).
     * @param value the value to store
     * @return the extended context for fluent method calls
     */
    public ErrorContext withContext(String label, Object value) {
        if (Strings.isEmpty(label)) {
            return this;
        }
        if (Strings.isEmpty(value)) {
            this.context.remove(label);
        } else {
            this.context.put(label, NLS.toUserString(value));
        }

        return this;
    }

    /**
     * Removes the value with the given label from the context.
     *
     * @param label the label of the value to remove
     * @return the modified context for fluent method calls
     */
    public ErrorContext removeContext(String label) {
        return withContext(label, null);
    }

    /**
     * Retrieves the value with the given label from the context.
     *
     * @param label the label of the value to retrieve
     * @return the value stored in the context or <tt>null</tt> if no value is stored
     */
    public String getContextValue(String label) {
        return context.get(label);
    }

    /**
     * Adds the given value to the context, performs the given task and then removes the value again.
     *
     * @param label the name of the value (this will be {@link NLS#smartGet(String) auto translated}).
     * @param value the value to store
     * @param task  the task to perform while the value is set
     * @return the context for fluent method calls
     * @throws Exception any error as thrown by the given task. Note that the exceptions are not handled and also
     *                   not automatically {@link #enhanceMessage(String) enhanced}.
     */
    public ErrorContext inContext(String label, Object value, UnitOfWork task) throws Exception {
        withContext(label, value);
        try {
            task.execute();
        } finally {
            removeContext(label);
        }

        return this;
    }

    /**
     * Executes the given producer and if any exception happens, applies the given failure description and throws a handled exception.
     *
     * @param failureDescription annotates a given error message so that the user is notified what task actually went
     *                           wrong. This should be in "negative form" like "Cannot perform x because: message" as
     *                           it is only used for error reporting.
     * @param producer           the producer to execute
     * @return the object created by the given producer
     */
    public <T> T annotateExceptionAndGet(UnaryOperator<String> failureDescription, Producer<T> producer) {
        try {
            return producer.create();
        } catch (HandledException exception) {
            Exceptions.ErrorHandler forwarded =
                    Exceptions.createHandled().withDirectMessage(failureDescription.apply(exception.getMessage()));
            exception.getHint(ProcessLog.HINT_MESSAGE_TYPE)
                     .ifFilled(key -> forwarded.hint(ProcessLog.HINT_MESSAGE_TYPE, key));
            exception.getHint(ProcessLog.HINT_MESSAGE_COUNT)
                     .ifFilled(count -> forwarded.hint(ProcessLog.HINT_MESSAGE_COUNT, count));
            throw forwarded.handle();
        } catch (Exception exception) {
            throw Exceptions.handle()
                            .to(Log.BACKGROUND)
                            .withDirectMessage(failureDescription.apply(exception.getMessage()))
                            .handle();
        }
    }

    /**
     * Obtains the current context as string.
     *
     * @return the current error context as string
     */
    public String getContextAsString() {
        return context.entrySet()
                      .stream()
                      .map(entry -> NLS.smartGet(entry.getKey()) + ": " + entry.getValue())
                      .collect(Collectors.joining(", "));
    }

    /**
     * Logs an {@link ProcessLogType#ERROR error} including the current context.
     * <p>
     * This will obey hints provided with the exception, such as the ones used to limit the amount
     * of entries logged for a specific type.
     *
     * @param exception the exception to log
     */
    public void logExceptionAsError(HandledException exception) {
        logException(exception, ProcessLogType.ERROR);
    }

    /**
     * Logs a {@link ProcessLogType#WARNING warning} including the current context.
     * <p>
     * This will obey hints provided with the exception, such as the ones used to limit the amount
     * of entries logged for a specific type.
     *
     * @param exception the exception to log
     */
    public void logExceptionAsWarning(HandledException exception) {
        logException(exception, ProcessLogType.WARNING);
    }

    private void logException(HandledException exception, ProcessLogType processLogType) {
        TaskContext taskContext = TaskContext.get();
        if (taskContext.getAdapter() instanceof ProcessContext processContext) {
            processContext.log(new ProcessLog().withType(processLogType)
                                               .withHandledException(exception)
                                               .withMessage(enhanceMessage(exception.getMessage())));
        } else {
            taskContext.log(enhanceMessage(exception.getMessage()));
        }
    }

    /**
     * Enhances the given error message by appending the current content.
     *
     * @param errorMessage the message to enhance
     * @return the enhanced error message
     */
    public String enhanceMessage(String errorMessage) {
        String contextAsString = getContextAsString();
        if (Strings.isFilled(contextAsString)) {
            return errorMessage + " (" + contextAsString + ")";
        } else {
            return errorMessage;
        }
    }

    /**
     * Performs the given task and handles / {@link #enhanceMessage(String) enhances} all thrown errors.
     *
     * @param task the task to actually perform
     */
    public void handle(UnitOfWork task) {
        handleAndGet(() -> {
            task.execute();
            return null;
        });
    }

    /**
     * Executes the given task and handles / {@link #enhanceMessage(String) enhances} all thrown errors.
     *
     * @param failureDescription annotates a given error message so that the user is notified what task actually went
     *                           wrong. This should be in "negative form" like "Cannot perform x because: message" as
     *                           it is only used for error reporting.
     * @param task               the task to actually perform
     */
    public void handle(UnaryOperator<String> failureDescription, UnitOfWork task) {
        handleAndGet(failureDescription, () -> {
            task.execute();
            return null;
        });
    }

    /**
     * Executes the given task and directly logs any occurring error.
     *
     * @param label the name of the value (this will be {@link NLS#smartGet(String) auto translated}).
     * @param value the value to store
     * @param task  the task to perform
     */
    public void handleInContext(String label, Object value, UnitOfWork task) {
        handleInContextAndGet(label, value, () -> {
            task.execute();
            return null;
        });
    }

    /**
     * Executes the given task and directly logs any occurring error.
     *
     * @param failureDescription annotates a given error message so that the user is notified what task actually went
     *                           wrong. This should be in "negative form" like "Cannot perform x because: message" as
     *                           it is only used for error reporting.
     * @param label              the name of the value (this will be {@link NLS#smartGet(String) auto translated}).
     * @param value              the value to store
     * @param task               the task to perform
     */
    public void handleInContext(UnaryOperator<String> failureDescription, String label, Object value, UnitOfWork task) {
        handleInContextAndGet(failureDescription, label, value, () -> {
            task.execute();
            return null;
        });
    }

    /**
     * Executes the given producer and directly reports any occurring error.
     *
     * @param producer the producer to execute
     * @return an optional containing the object returned by the producer or an empty optional if exceptions happened during execution
     */
    public <T> Optional<T> handleAndGet(Producer<T> producer) {
        return handleInContextAndGet(null, null, producer);
    }

    /**
     * Executes the given producer and directly reports any occurring error.
     *
     * @param failureDescription annotates a given error message so that the user is notified what task actually went
     *                           wrong. This should be in "negative form" like "Cannot perform x because: message" as
     *                           it is only used for error reporting.
     * @param producer           the producer to execute
     * @return an optional containing the object returned by the producer or an empty optional if exceptions happened during execution
     */
    public <T> Optional<T> handleAndGet(UnaryOperator<String> failureDescription, Producer<T> producer) {
        return handleInContextAndGet(failureDescription, null, null, producer);
    }

    /**
     * Executes the given producer and directly reports any occurring error.
     *
     * @param label    the name of the value (this will be {@link NLS#smartGet(String) auto translated}).
     * @param value    the value to store
     * @param producer the producer to execute
     * @return an optional containing the object returned by the producer or an empty optional if exceptions happened during execution
     */
    public <T> Optional<T> handleInContextAndGet(String label, Object value, Producer<T> producer) {
        withContext(label, value);
        try {
            return Optional.ofNullable(producer.create());
        } catch (HandledException exception) {
            logException(exception, ProcessLogType.ERROR);
        } catch (Exception exception) {
            String message = exception.getMessage() + " (" + exception.getClass().getName() + ")";
            logException(Exceptions.handle().to(Log.BACKGROUND).error(exception).withDirectMessage(message).handle(),
                         ProcessLogType.ERROR);
        } finally {
            removeContext(label);
        }
        return Optional.empty();
    }

    /**
     * Executes the given producer and directly reports any occurring error.
     *
     * @param failureDescription annotates a given error message so that the user is notified what task actually went
     *                           wrong. This should be in "negative form" like "Cannot perform x because: message" as
     *                           it is only used for error reporting.
     * @param label              the name of the value (this will be {@link NLS#smartGet(String) auto translated}).
     * @param value              the value to store
     * @param producer           the producer to execute
     * @return an optional containing the object returned by the producer or an empty optional if exceptions happened during execution
     */
    public <T> Optional<T> handleInContextAndGet(UnaryOperator<String> failureDescription,
                                                 String label,
                                                 Object value,
                                                 Producer<T> producer) {
        return handleInContextAndGet(label, value, () -> annotateExceptionAndGet(failureDescription, producer));
    }

    /**
     * Executes the given task and if any exception happens, applies the given failure description and throws a handled exception.
     *
     * @param failureDescription annotates a given error message so that the user is notified what task actually went
     *                           wrong. This should be in "negative form" like "Cannot perform x because: message" as
     *                           it is only used for error reporting.
     * @param task               the task to execute
     */
    public void annotateException(UnaryOperator<String> failureDescription, UnitOfWork task) {
        annotateExceptionAndGet(failureDescription, () -> {
            task.execute();
            return null;
        });
    }

    /**
     * Performs the given task as "import" of the given entity.
     * <p>
     * This will report a canned error message if the task fails.
     *
     * @param entityDescriptor the name or label which identifies the entity being imported. When in doubt, use
     *                         <tt>entity::toString</tt>.
     * @param task             the import task to perform
     */
    public void performImport(Supplier<String> entityDescriptor, UnitOfWork task) {
        handle(() -> annotateException(message -> NLS.fmtr("ErrorContext.importError")
                                                     .set("message", message)
                                                     .set("entity", entityDescriptor.get())
                                                     .format(), task));
    }

    /**
     * Performs the given task "deleting" the given entity.
     * <p>
     * This will report a canned error message if the task fails.
     *
     * @param entityDescriptor the name or label which identifies the entity being deleted. When in doubt, use
     *                         <tt>entity::toString</tt>.
     * @param task             the import task to perform
     */
    public void performDelete(Supplier<String> entityDescriptor, UnitOfWork task) {
        handle(() -> annotateException(message -> NLS.fmtr("ErrorContext.deleteError")
                                                     .set("message", message)
                                                     .set("entity", entityDescriptor.get())
                                                     .format(), task));
    }

    @Override
    public SubContext fork() {
        ErrorContext fork = new ErrorContext();
        fork.context.putAll(this.context);
        return fork;
    }

    @Override
    public void detach() {
        context.clear();
    }
}
