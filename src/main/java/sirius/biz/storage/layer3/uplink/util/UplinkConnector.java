/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.biz.storage.layer3.uplink.util;

import org.apache.commons.pool2.impl.DefaultPooledObjectInfo;
import sirius.biz.storage.util.StorageUtils;
import sirius.kernel.async.ExecutionPoint;
import sirius.kernel.async.Operation;
import sirius.kernel.health.Exceptions;

import java.io.Closeable;
import java.io.IOException;
import java.util.function.Consumer;

/**
 * Encapsulates a pooled connector.
 * <p>
 * This is mainly used for bookkeeping by the {@link UplinkConnectorPool}.
 *
 * @param <C> the effective connector being wrapped
 */
public class UplinkConnector<C> implements Closeable {

    protected C connector;
    protected Consumer<C> forceCloseCallback;
    protected Consumer<UplinkConnector<C>> closeCallback;
    protected Operation operation;
    protected ExecutionPoint borrowedPoint;

    protected UplinkConnector(C connector) {
        this.connector = connector;
    }

    /**
     * Returns the wrapped connector.
     *
     * @return the wrapped connector
     */
    public C connector() {
        return connector;
    }

    @Override
    public void close() throws IOException {
        safeClose();
    }

    /**
     * Forcefully closes the connector so that it will be destroyed once it is returned via {@link #safeClose()} or
     * {@link #close()}.
     * <p>
     * Note that one of the close methods must still be called so that the connection pool remains in a consistent
     * state.
     */
    public void forceClose() {
        try {
            StorageUtils.LOG.FINE("Layer 3/Uplinks: Force-closing: %s", this);
            forceCloseCallback.accept(connector);
        } catch (Exception exception) {
            StorageUtils.LOG.FINE("Layer 3/Uplinks: Force-closing of %s failed: %s",
                                  this,
                                  exception.getMessage(),
                                  exception.getClass().getName());
            Exceptions.ignore(exception);
        }
    }

    /**
     * Closes the connector and handles any exception internally.
     */
    public void safeClose() {
        try {
            closeCallback.accept(this);
        } catch (Exception exception) {
            Exceptions.handle()
                      .to(StorageUtils.LOG)
                      .error(exception)
                      .withSystemErrorMessage("Layer 3/Uplinks: An error occurred while closing a connector: %s (%s)")
                      .handle();
        }
    }

    /**
     * Provides a stacktrace of where the object was borrowed.
     * <p>
     * We need to hijack the <tt>toString</tt> method as this is accessible via
     * {@link DefaultPooledObjectInfo#getPooledObjectToString()} and used by {@link ListUplinkConnectorsCommand}.
     *
     * @return the point where the object was borrowed or "idle" if it currently resides in the pool
     */
    @Override
    public String toString() {
        if (borrowedPoint != null) {
            return borrowedPoint.toString();
        } else {
            return "idle";
        }
    }

    /**
     * Provides a simple <tt>toString</tt> method as the real one is hijacked for reporting purposes.
     *
     * @return the output as generated by {@link Object#toString()}
     */
    public String toSimpleString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
}
