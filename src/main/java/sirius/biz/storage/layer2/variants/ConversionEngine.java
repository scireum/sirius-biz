/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.biz.storage.layer2.variants;

import sirius.biz.process.ProcessContext;
import sirius.biz.process.Processes;
import sirius.biz.process.logs.ProcessLog;
import sirius.biz.storage.layer1.FileHandle;
import sirius.biz.storage.util.StorageUtils;
import sirius.biz.tenants.Tenants;
import sirius.kernel.Sirius;
import sirius.kernel.async.Future;
import sirius.kernel.async.Tasks;
import sirius.kernel.commons.Strings;
import sirius.kernel.commons.Value;
import sirius.kernel.commons.Watch;
import sirius.kernel.di.GlobalContext;
import sirius.kernel.di.std.Part;
import sirius.kernel.di.std.Register;
import sirius.kernel.health.Average;
import sirius.kernel.health.Exceptions;
import sirius.kernel.nls.NLS;
import sirius.kernel.settings.Extension;

import javax.annotation.Nullable;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Responsible for generating {@link BlobVariant variants} of a given blob.
 * <p>
 * Each blob can have any number of variants (e.g. resized JPG images of a given raw or EPS file). Each variant has
 * a distinctive name. This name is used to lookup the appropriate conversion pipeline by inspecting the system
 * config section {@link #CONFIG_KEY_VARIANTS}.
 * <p>
 * These settings will be used and passed on to the selected {@link Converter}. Note that the converter isn't
 * specified directly, but another config section in {@link #CONFIG_KEY_CONVERTERS} is used to determine the effective
 * implementation (addressing the appropriate {@link ConverterFactory} along with default settings).
 * <p>
 * Using this approach we can provide some standard converters and standard variants which can be fully customized
 * in applications by either overwriting the variants or the converters.
 */
@Register(classes = ConversionEngine.class)
public class ConversionEngine {

    private static final String CONFIG_KEY_VARIANTS = "storage.layer2.conversion.variants";
    private static final String CONFIG_KEY_FILE_EXTENSION = "fileExtension";
    private static final String CONFIG_KEY_CONVERTER = "converter";
    private static final String CONFIG_KEY_CONVERTERS = "storage.layer2.conversion.converters";
    private static final String EXECUTOR_STORAGE_CONVERSION = "storage-conversion";
    private static final String CONFIG_KEY_TYPE = "type";

    private final Average conversionDuration = new Average();

    @Part
    private Tasks tasks;

    @Part
    private GlobalContext globalContext;

    @Part
    @Nullable
    private Processes processes;

    @Part
    @Nullable
    private Tenants<?, ?, ?> tenants;

    /**
     * When delivering files (e.g. preview images to be shown in the browser), we normally don't bother to look up the
     * original filename of the image (as this would require a DB lookup). However, we need to generate a name with
     * the appropriate file extension so that the <tt>Content-Type</tt> is set up properly.
     * <p>
     * Therefore we keep a map which stores the effective file extension per variant as this is both, frequently used
     * and constant over the lifetime of the system.
     */
    private Map<String, String> fileExtensionPerVariant;

    /**
     * Contains the fully initialized and configured {@link Converter} for each variant. As these are itself
     * stateless and remain constant over the lifetime of the system (and also probably expensive to instantiate),
     * we keep a list of instances around.
     */
    private final Map<String, Converter> converterPerVariant = new ConcurrentHashMap<>();

    /**
     * Returns the effective file extension of the files generated by a given variant.
     *
     * @param variant the name of the variant
     * @return the file extension of the files generated by the given variant or <tt>null</tt> if the file extension
     * isn't known or not constant.
     */
    @Nullable
    public String determineTargetFileExtension(String variant) {
        if (fileExtensionPerVariant == null) {
            initializeFileExtensions();
        }
        return fileExtensionPerVariant.get(variant);
    }

    protected void initializeFileExtensions() {
        fileExtensionPerVariant = Sirius.getSettings()
                                        .getExtensions(CONFIG_KEY_VARIANTS)
                                        .stream()
                                        .map(Extension::getId)
                                        .collect(Collectors.toMap(Function.identity(),
                                                                  variant -> getVariantConfig(variant).apply(
                                                                          CONFIG_KEY_FILE_EXTENSION).asString()));
    }

    /**
     * Determines if a configuration is present for the given variant name.
     *
     * @param variant the variant name to check
     * @return <tt>true</tt> if a configuration is present, <tt>false</tt> otherwise
     */
    public boolean isKnownVariant(String variant) {
        if (fileExtensionPerVariant == null) {
            initializeFileExtensions();
        }
        return fileExtensionPerVariant.containsKey(variant);
    }

    /**
     * Returns the cached converter instance for the given variant or creates a new converter if the cache is empty.
     *
     * @param variant the variant to find the converter for
     * @return the converter or <tt>null</tt> if a configuration problem is present for the requested converter
     */
    @Nullable
    private Converter fetchConverter(String variant) {
        return converterPerVariant.computeIfAbsent(variant, this::createConverter);
    }

    /**
     * Creates a new converter for the given variant.
     * <p>
     * This will use the {@link #CONFIG_KEY_VARIANTS variant config} and the
     * {@link #CONFIG_KEY_CONVERTERS converter config} to lookup and invoke the appropriate {@link ConverterFactory}.
     *
     * @param variant the variant for which the converter is to be created
     * @return the newly created converter or <tt>null</tt> if a configuration problem is present
     * @throws IllegalArgumentException if the variant is unknown
     */
    @Nullable
    private Converter createConverter(String variant) {
        Function<String, Value> variantConfigSupplier = getVariantConfig(variant);
        try {
            return globalContext.findPart(variantConfigSupplier.apply(CONFIG_KEY_TYPE).asString(),
                                          ConverterFactory.class).createConverter(variantConfigSupplier);
        } catch (Exception exception) {
            Exceptions.handle()
                      .error(exception)
                      .to(StorageUtils.LOG)
                      .withSystemErrorMessage("Failed to create a converter of type %s for %s: %s (%s)",
                                              variantConfigSupplier.apply(CONFIG_KEY_CONVERTER),
                                              variant)
                      .handle();

            return null;
        }
    }

    /**
     * Invokes the {@link Converter} which has been configured for the given variant to perform the actual conversion.
     *
     * @param conversionProcess the conversion to perform
     * @return a future which is fulfilled once the conversion is completed
     */
    public Future performConversion(ConversionProcess conversionProcess) {
        Future result = new Future();

        Watch queueWatch = Watch.start();
        tasks.executor(EXECUTOR_STORAGE_CONVERSION)
             .dropOnOverload(() -> result.fail(new IllegalStateException("Conversion subsystem overloaded!")))
             .fork(() -> doConversion(conversionProcess, result, queueWatch));

        return result;
    }

    private void doConversion(ConversionProcess conversionProcess, Future result, Watch queueWatch) {
        try {
            conversionProcess.recordQueueDuration(queueWatch.elapsedMillis());
            Converter converter = fetchConverter(conversionProcess.getVariantName());
            if (converter == null) {
                // We use a handled exception here as the error has already been reported, and we do not want to jam
                // the logs with additional error reports for the same problem.
                throw Exceptions.createHandled()
                                .withSystemErrorMessage("A configuration problem is present for: %s",
                                                        conversionProcess.getVariantName())
                                .handle();
            }

            converter.performConversion(conversionProcess);

            FileHandle resultFileHandle = conversionProcess.getResultFileHandle();
            if (resultFileHandle == null || !resultFileHandle.exists() || resultFileHandle.getFile().length() == 0) {
                if (resultFileHandle != null) {
                    resultFileHandle.close();
                }

                throw Exceptions.createHandled()
                                .withSystemErrorMessage(Strings.apply(
                                        "The conversion engine created an empty result for variant %s of %s (%s)",
                                        conversionProcess.getVariantName(),
                                        conversionProcess.getBlobToConvert().getFilename(),
                                        conversionProcess.getBlobToConvert().getBlobKey()))
                                .handle();
            }

            conversionDuration.addValue(conversionProcess.getConversionDuration());
            result.success();
        } catch (Exception exception) {
            recordErrorInStandbyProcess(conversionProcess, exception);
            result.fail(exception);
        }
    }

    private void recordErrorInStandbyProcess(ConversionProcess conversionProcess, Exception exception) {
        String blobTenantId = conversionProcess.getBlobToConvert().getTenantId();
        if (processes != null && tenants != null && Strings.isFilled(blobTenantId)) {
            processes.executeInStandbyProcess("conversion",
                                              () -> NLS.get("ConversionEngine.processTitle"),
                                              blobTenantId,
                                              () -> tenants.fetchCachedTenantName(blobTenantId),
                                              processContext -> createStandbyProcessLogEntry(conversionProcess,
                                                                                             processContext,
                                                                                             exception.getMessage()));
        }
    }

    private void createStandbyProcessLogEntry(ConversionProcess conversionProcess,
                                              ProcessContext processContext,
                                              String message) {
        processContext.log(ProcessLog.error()
                                     .withNLSKey("ConversionEngine.conversionError")
                                     .withContext("variantName", NLS.quote(conversionProcess.getVariantName()))
                                     .withContext("filename", NLS.quote(conversionProcess.getBlobToConvert().getFilename()))
                                     .withContext("message", message));
    }

    /**
     * Exposes the metric which records the conversion performed on this node.
     * <p>
     * This is mainly exposed by the used by {@link sirius.biz.storage.util.StorageMetrics}.
     *
     * @return the average which records the conversion duration for this node
     */
    public Average getConversionDuration() {
        return conversionDuration;
    }

    /**
     * Creates a config supplier for a variant which combines its config with the converter config.
     *
     * @param variant the variant for which a config supplier should be returned
     * @return a function which takes a key and returns the config value for this variant and key.
     */
    public Function<String, Value> getVariantConfig(String variant) {
        Extension variantConfig = Sirius.getSettings().getExtension(CONFIG_KEY_VARIANTS, variant);

        if (variantConfig == null || variantConfig.isDefault()) {
            throw new IllegalArgumentException("Unknown variant: " + variant);
        }

        String converter = variantConfig.get(CONFIG_KEY_CONVERTER).asString();
        Extension converterConfig = Sirius.getSettings().getExtension(CONFIG_KEY_CONVERTERS, converter);

        return configKey -> {
            Value variantValue = variantConfig.get(configKey);
            if (variantValue.isNull()) {
                return converterConfig.get(configKey);
            }
            return variantValue;
        };
    }
}
