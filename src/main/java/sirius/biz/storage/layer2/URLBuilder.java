/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.biz.storage.layer2;

import sirius.biz.storage.layer2.variants.ConversionEngine;
import sirius.biz.storage.util.StorageUtils;
import sirius.kernel.commons.Files;
import sirius.kernel.commons.StringCleanup;
import sirius.kernel.commons.Strings;
import sirius.kernel.commons.Tuple;
import sirius.kernel.commons.Urls;
import sirius.kernel.commons.Value;
import sirius.kernel.di.std.ConfigValue;
import sirius.kernel.di.std.Part;
import sirius.kernel.health.Exceptions;
import sirius.kernel.health.HandledException;
import sirius.pasta.noodle.sandbox.NoodleSandbox;

import javax.annotation.Nullable;
import java.util.Optional;
import java.util.regex.Pattern;

/**
 * Represents a <b>builder</b> to generate delivery URLs for {@link Blob blobs} via the {@link BlobDispatcher}.
 */
public class URLBuilder {

    /**
     * Contains the variant name which delivers the actual contents of the blob without any conversion.
     */
    public static final String VARIANT_RAW = "raw";

    /**
     * Matches all non-url characters in the given <tt>addonText</tt> which will be replaced by "-" in
     * {@link #appendAddonText(StringBuilder)}.
     */
    private static final Pattern NON_URL_CHARACTERS = Pattern.compile("[^a-zA-Z0-9_.]");

    /**
     * Contains the default fallback URI used by {@link #buildImageURL()}.
     * <p>
     * Note that a custom URI can be provided via {@link #withFallbackUri(String)}
     * or {@link BlobHardRef#withFallbackUri(String)}.
     */
    public static final String IMAGE_FALLBACK_URI = "/assets/images/blob_image_fallback.png";

    /**
     * Contains the default failed fallback image.
     * <p>
     * The image will be displayed if a conversion has finally failed.
     */
    public static final String IMAGE_FAILED_URI = "/assets/images/blob_image_failed.png";

    protected BlobStorageSpace space;
    protected Blob blob;
    protected String blobKey;
    protected String variant = VARIANT_RAW;
    protected String cachedPhysicalKey;
    protected String filename;
    protected String baseURL;
    protected String addonText;
    protected boolean delayResolve;
    protected boolean eternallyValid;
    protected boolean forceDownload;
    protected boolean suppressCache;
    protected String hook;
    protected String payload;
    protected String fallbackUri;
    protected boolean largeFile;
    protected boolean hasLargeFileCheck;
    protected boolean waitLonger;

    @Part
    private static StorageUtils utils;

    @Part
    private static ConversionEngine conversionEngine;

    @ConfigValue("storage.layer2.largeFileLimit")
    private static long largeFileLimit;

    /**
     * Contains the {@linkplain #buildUrlResult() generated URL} and an {@linkplain UrlType indicator} if it is a
     * virtual, physical, the fallback URL, or empty.
     *
     * @param url     the URL generated by this url builder
     * @param urlType the type of URL that was generated
     */
    public record UrlResult(String url, UrlType urlType) {
    }

    /**
     * Indicates if the {@linkplain #buildUrlResult() generated URL} is a virtual, physical, the fallback URL or empty.
     */
    public enum UrlType {
        /**
         * Requested variant does not exist, no fallback provided.
         */
        EMPTY,
        /**
         * Requested variant does not exist, but a fallback was provided and used.
         */
        FALLBACK,
        /**
         * Either explicitly requested, or the requested variant exists, but has no physical key yet.
         */
        VIRTUAL,
        /**
         * Requested variant exists and its conversion is completed.
         */
        PHYSICAL
    }

    /**
     * Creates a new builder with a direct reference to the space and the blob key.
     *
     * @param space   the storage space which manages the blob
     * @param blobKey the blob key to download
     */
    public URLBuilder(BlobStorageSpace space, String blobKey) {
        this.space = space;
        this.blobKey = blobKey;
        this.blob = null;
    }

    /**
     * Creates a new builder with a direct reference to the blob.
     *
     * @param space the storage space which manages the blob
     * @param blob  the blob download
     */
    public URLBuilder(BlobStorageSpace space, Blob blob) {
        this.space = space;
        this.blobKey = blob.getBlobKey();
        this.blob = blob;
    }

    /**
     * Specifies a fallback URI to deliver if no blob or blob-key is available.
     *
     * @param fallbackUri the fallback URI to use
     * @return the builder itself for fluent method calls
     * @see #IMAGE_FALLBACK_URI
     * @see #safeBuildURL(String)
     * @see #buildImageURL()
     */
    public URLBuilder withFallbackUri(String fallbackUri) {
        this.fallbackUri = fallbackUri;
        return this;
    }

    /**
     * Specifies the version of the file to use.
     * <p>
     * If a value (other than {@link #VARIANT_RAW}) is given, the selected variant is delivered. If the variant
     * does not exist yet, an appropriate URL is generated which will then generate and deliver the variant.
     * <p>
     * The type of variants and how these are created is specified in the system configuration and managed by the
     * {@link ConversionEngine}.
     *
     * @param variant the name of the variant to deliver
     * @return the builder itself for fluent method calls
     * @see ConversionEngine
     */
    public URLBuilder withVariant(String variant) {
        if (hasLargeFileCheck && Strings.isFilled(variant) && !Strings.areEqual(variant, VARIANT_RAW)) {
            throw new IllegalStateException("enableLargeFileDetection() cannot be used along withVariant()!");
        }

        this.variant = variant;
        this.cachedPhysicalKey = null;

        return this;
    }

    /**
     * Adds the marker to virtual URLs that the caller is willing to wait longer for the conversion to complete.
     *
     * @return the builder itself for fluent method calls
     */
    public URLBuilder waitLonger() {
        this.waitLonger = true;
        return this;
    }

    /**
     * Specifies the name of the file.
     *
     * @param path the filename to send to the browser
     * @return the builder itself for fluent method calls
     */
    public URLBuilder withFileName(String path) {
        this.filename = Files.getFilenameAndExtension(path);
        return this;
    }

    /**
     * Make the URL a download url using the filename of the blob.
     *
     * @return the builder itself for fluent method calls
     */
    @NoodleSandbox(NoodleSandbox.Accessibility.GRANTED)
    public URLBuilder asDownload() {
        this.forceDownload = true;

        return this;
    }

    /**
     * Enables a check which determines if the underlying file is considered "too large to be cached".
     * <p>
     * Downstream reverse proxies like Varnish are heavily impact by very large files (GBs). Therefore, this
     * check can be enabled. If we then detect that the underlying file is larger than {@link #largeFileLimit}
     * (specified in the config by <tt>storage.layer2.largeFileLimit</tt>), we add a special prefix to the
     * URL (<tt>/dasd/xxl</tt>). This prefix is cut away by the {@link BlobDispatcher} and doesn't change the
     * processing at all. However, a downstream reverse proxy can detect such links and by-pass caching etc.
     * entirely.
     * <p>
     * This has to be enabled manually, as such large downloads are infrequent and require a lookup for the
     * filesize.
     * <p>
     * Note that this doesn't support selecting a specific variant, as we can only inspect the blob and its size
     * itself. Use {@link #markAsLargeFile()} if a variant is requested.
     *
     * @return the builder itself for fluent method calls
     */
    public URLBuilder enableLargeFileDetection() {
        if (Strings.isFilled(variant) && !VARIANT_RAW.equals(variant)) {
            throw new IllegalStateException("enableLargeFileDetection() cannot be used along withVariant()!");
        }

        this.hasLargeFileCheck = true;

        if (Strings.isFilled(blobKey) && blob == null) {
            space.findByBlobKey(blobKey).ifPresent(resolvedBlob -> this.blob = resolvedBlob);
        }
        if (isConsideredLarge(blob)) {
            this.largeFile = true;
        }

        return this;
    }

    /**
     * Forcefully marks the underlying file is considered "too large to be cached".
     * <p>
     * This can be used if a variant is selected which is known to still be very large. Note that
     * {@link #enableLargeFileDetection()} currently does not support variants to be selected, as we only inspect
     * the blob itself.
     *
     * @return the builder itself for fluent method calls
     */
    public URLBuilder markAsLargeFile() {
        this.largeFile = true;
        return this;
    }

    /**
     * Determines if the given blob is considered a {@link #largeFileLimit} large file.
     *
     * @param blob the blob to check
     * @return <tt>true</tt> if the blob is considered large, <tt>false</tt> otherwise@
     */
    public static boolean isConsideredLarge(@Nullable Blob blob) {
        return blob != null && blob.getSize() > largeFileLimit;
    }

    /**
     * Specifies the base URL to use.
     * <p>
     * Note that the system tries to provide a proper base URL based on the <b>storage space</b> in which
     * the blob resides. Therefore, this method only needs to be invoked if an external / exotic base URL is to be used.
     *
     * @param baseURL the base URL to use
     * @return the builder itself for fluent method calls
     */
    public URLBuilder withBaseURL(String baseURL) {
        this.baseURL = baseURL;
        return this;
    }

    /**
     * Makes this URL eternally valid.
     * <p>
     *
     * @return the builder itself for fluent method calls
     */
    public URLBuilder eternallyValid() {
        this.eternallyValid = true;
        return this;
    }

    /**
     * Instructs the system to use the virtual blob URL instead of resolving the physical URL.
     * <p>
     * This might be feasible, if the caller knows, that there is a great chance, that the URL being generated is
     * not actually invoked. We therefore can generate a virtual URL (which requires no additional lookup, but is
     * not as "cacheable" as a physical one).
     *
     * @return the builder itself for fluent method calls
     */
    public URLBuilder delayResolve() {
        this.delayResolve = true;
        return this;
    }

    /**
     * Disables HTTP caching entirely.
     *
     * @return the builder itself for fluent method calls
     */
    public URLBuilder suppressCaching() {
        this.suppressCache = true;
        return this;
    }

    /**
     * Permits adding additional text to the URL which is ignored by the {@link BlobDispatcher}.
     * <p>
     * This can be used to add SEO texts for image URLs...
     *
     * @param text the text to include in the URL (will be escaped properly).
     * @return the builder itself for fluent method calls
     */
    public URLBuilder withAddonText(String text) {
        this.addonText = text;
        return this;
    }

    /**
     * Permits to trigger a {@link BlobDispatcherHook} once the blob was completely delivered.
     * <p>
     * This can be used to emit events etc.
     *
     * @param hook    the name of the hook to trigger
     * @param payload the payload to send to the trigger (e.g. a database id or the like)
     * @return the builder itself for fluent method calls
     */
    public URLBuilder withHook(String hook, @Nullable String payload) {
        this.hook = hook;
        this.payload = payload;
        return this;
    }

    /**
     * Builds the effective URL according to the parameters specified wrapped in an {@link Optional}.
     * <p>
     * {@link Optional#empty()} is returned when the file cannot be found in the storage engine.
     *
     * @return the url generated by this builder wrapped in an {@link Optional} or {@link Optional#empty()}
     * if no file was found in the storage engine
     */
    @NoodleSandbox(NoodleSandbox.Accessibility.GRANTED)
    public Optional<String> buildURL() {
        try {
            UrlResult urlResult = buildUrlResult();
            if (urlResult.urlType() == UrlType.EMPTY) {
                return Optional.empty();
            } else {
                return Optional.of(urlResult.url);
            }
        } catch (HandledException exception) {
            // A handled exception here means we've exceeded the maximum number of attempts to convert the variant.
            Exceptions.ignore(exception);
            return Optional.empty();
        }
    }

    /**
     * Builds the effective URL according to the parameters specified and returns a matching {@link UrlResult}.
     *
     * @return the {@link UrlResult} containing the generated URL and an {@linkplain UrlType indicator} if it is a
     * virtual, physical, the fallback URL or empty.
     */
    public UrlResult buildUrlResult() {
        if (Strings.isEmpty(blobKey) || (blob != null && Strings.isEmpty(blob.getPhysicalObjectKey()))) {
            if (Strings.isFilled(fallbackUri)) {
                return new UrlResult(createBaseURL().append(fallbackUri).toString(), UrlType.FALLBACK);
            }
            return new UrlResult(null, UrlType.EMPTY);
        }

        if (suppressCache) {
            // Manual cache control is only supported in virtual calls, not physical...
            return new UrlResult(createVirtualDeliveryUrl(), UrlType.VIRTUAL);
        }
        if (delayResolve && !isPhysicalKeyReadilyAvailable()) {
            // The caller specifically requested, that we do not forcefully compute the physical URL (which might
            // require a lookup), but to rather use the virtual URL...
            return new UrlResult(createVirtualDeliveryUrl(), UrlType.VIRTUAL);
        }

        return createPhysicalDeliveryUrlResult();
    }

    /**
     * Builds the URL and permits to specify a custom fallback URI to deliver if no blob or blob-key is available.
     *
     * @param fallbackUri the fallback URI to use
     * @return the effective URL to use
     * @see #IMAGE_FALLBACK_URI
     * @see #withFallbackUri(String)
     * @see #buildImageURL()
     */
    public String safeBuildURL(String fallbackUri) {
        return buildURL().orElseGet(() -> createBaseURL().append(fallbackUri).toString());
    }

    /**
     * Builds the URL based on the given parameters or uses a generic fallback image if no blob or blob-key is
     * available.
     *
     * @return the effective URL to use
     * @see #IMAGE_FALLBACK_URI
     * @see #withFallbackUri(String)
     * @see #safeBuildURL(String)
     */
    public String buildImageURL() {
        try {
            UrlResult urlResult = buildUrlResult();
            if (urlResult.urlType() == UrlType.EMPTY) {
                return createBaseURL().append(IMAGE_FALLBACK_URI).toString();
            } else {
                return urlResult.url();
            }
        } catch (HandledException exception) {
            // A handled exception here means we've exceeded the maximum number of attempts to convert the variant.
            Exceptions.ignore(exception);
            return createBaseURL().append(IMAGE_FAILED_URI).toString();
        }
    }

    /**
     * Determines if a conversion for the given variant is expected.
     *
     * @return <tt>true</tt> if a variant is selected, for which no physical key is present. <tt>false</tt> if there
     * already exists a physical key for the given variant or a conversion ultimately failed.
     */
    public boolean isConversionExpected() {
        try {
            return isFilled() && !Strings.areEqual(variant, VARIANT_RAW) && Strings.isEmpty(determinePhysicalKey());
        } catch (HandledException exception) {
            // A handled exception here means we've exceeded the maximum number of attempts to convert the variant.
            Exceptions.ignore(exception);
            return false;
        }
    }

    /**
     * Determines if the builder is actually filled.
     *
     * @return <tt>true</tt> if a blob or blobKey is present, <tt>false</tt> otherwise
     */
    public boolean isFilled() {
        return blob != null || Strings.isFilled(blobKey);
    }

    /**
     * Obtains the fallback URI if present.
     *
     * @return the fallback URI or an empty optional if no fallback URI is present
     */
    public Optional<String> getFallbackUri() {
        return Optional.ofNullable(fallbackUri);
    }

    protected boolean isPhysicalKeyReadilyAvailable() {
        // If the raw file is requested and the blob object is available, we can easily determine the effective
        // physical key to serve.
        return Strings.areEqual(variant, VARIANT_RAW) && blob != null;
    }

    private UrlResult createPhysicalDeliveryUrlResult() {
        StringBuilder result = createBaseURL();

        String physicalKey = null;
        try {
            physicalKey = determinePhysicalKey();
        } catch (Exception exception) {
            // The conversion ultimately failed. Return the fallback URL if specified, otherwise an empty result.
            Exceptions.ignore(exception);
            if (Strings.isFilled(fallbackUri)) {
                return new UrlResult(createBaseURL().append(fallbackUri).toString(), UrlType.FALLBACK);
            } else {
                return new UrlResult(null, UrlType.EMPTY);
            }
        }

        if (Strings.isEmpty(physicalKey)) {
            return new UrlResult(createVirtualDeliveryUrl(), UrlType.VIRTUAL);
        }

        result.append(BlobDispatcher.URI_PREFIX_TRAILED);
        if (largeFile) {
            result.append(BlobDispatcher.LARGE_FILE_MARKER);
        }
        result.append(BlobDispatcher.FLAG_PHYSICAL);
        if (forceDownload) {
            result.append(BlobDispatcher.FLAG_DOWNLOAD);
        }

        result.append("/");
        result.append(space.getName());
        result.append("/");
        result.append(computeAccessToken(physicalKey));
        result.append("/");
        result.append(blobKey);
        result.append("/");
        if (forceDownload) {
            appendFilename(result, physicalKey, determineEffectiveFilename());
        } else if (Strings.isFilled(filename)) {
            appendFilename(result, physicalKey, filename);
        } else {
            appendAddonText(result);
            result.append(physicalKey);
            result.append(fetchUrlEncodedFileExtension());
        }

        appendHook(result);

        return new UrlResult(result.toString(), UrlType.PHYSICAL);
    }

    private void appendFilename(StringBuilder result, String physicalKey, String filename) {
        result.append(physicalKey);
        result.append("/");
        appendAddonText(result);
        result.append(Urls.encode(Files.toSaneFileName(filename).orElse(physicalKey + fetchUrlEncodedFileExtension())));
    }

    private String createVirtualDeliveryUrl() {
        StringBuilder result = createBaseURL();
        result.append(BlobDispatcher.URI_PREFIX_TRAILED);
        if (largeFile) {
            result.append(BlobDispatcher.LARGE_FILE_MARKER);
        }
        if (!suppressCache) {
            result.append(BlobDispatcher.FLAG_CACHEABLE);
        }
        result.append(BlobDispatcher.FLAG_VIRTUAL);
        if (forceDownload) {
            result.append(BlobDispatcher.FLAG_DOWNLOAD);
        }
        result.append("/");
        result.append(space.getName());
        result.append("/");
        result.append(computeAccessToken(blobKey + "-" + variant));
        result.append("/");
        result.append(variant);
        if (forceDownload) {
            result.append("/");
            result.append(blobKey);
            result.append("/");
            appendAddonText(result);
            result.append(Urls.encode(determineEffectiveFilename()));
        } else {
            result.append("/");
            appendAddonText(result);
            result.append(blobKey);
            result.append(fetchUrlEncodedFileExtension());
        }

        boolean hasHook = appendHook(result);

        if (waitLonger) {
            result.append(Strings.apply("%s%s=true", hasHook ? "&" : "?", BlobDispatcher.WAIT_LONGER_PARAMETER));
        }

        return result.toString();
    }

    /**
     * Appends the given hook name and payload if present.
     * <p>
     * This will be picked up by the BlobDispatcher and will trigger the matching
     * BlobDispatcherHook...
     *
     * @param urlBuilder the builder to append the strings to
     * @return <tt>true</tt> if a hook was appended, <tt>false</tt> otherwise
     */
    private boolean appendHook(StringBuilder urlBuilder) {
        if (Strings.isFilled(hook)) {
            urlBuilder.append("?hook=");
            urlBuilder.append(Urls.encode(hook));
            if (Strings.isFilled(payload)) {
                urlBuilder.append("&payload=");
                urlBuilder.append(Urls.encode(payload));
            }
            return true;
        }
        return false;
    }

    /**
     * Creates the base url.
     *
     * @return a StringBuilder prefilled with the base url.
     */
    public StringBuilder createBaseURL() {
        StringBuilder result = new StringBuilder();
        if (Strings.isFilled(baseURL)) {
            result.append(baseURL);
        } else {
            ((BasicBlobStorageSpace<?, ?, ?>) space).getBaseURL().ifPresent(result::append);
        }

        return result;
    }

    private String determinePhysicalKey() {
        if (blob != null && Strings.areEqual(variant, URLBuilder.VARIANT_RAW)) {
            return blob.getPhysicalObjectKey();
        }

        if (cachedPhysicalKey == null) {
            Tuple<String, Boolean> physicalKey =
                    ((BasicBlobStorageSpace<?, ?, ?>) space).tryFetchPhysicalKey(blobKey, variant);
            if (physicalKey != null) {
                this.cachedPhysicalKey = physicalKey.getFirst();
            }
        }

        return cachedPhysicalKey;
    }

    private String computeAccessToken(String authToken) {
        if (eternallyValid) {
            return utils.computeEternallyValidHash(authToken);
        } else {
            return utils.computeHash(authToken, 0);
        }
    }

    private void appendAddonText(StringBuilder result) {
        if (Strings.isFilled(addonText)) {
            result.append(Strings.cleanup(addonText,
                                          text -> NON_URL_CHARACTERS.matcher(addonText).replaceAll("-"),
                                          StringCleanup::reduceCharacters));
            result.append("--");
        }
    }

    private String determineFilename() {
        if (Strings.isFilled(filename)) {
            return filename;
        }
        if (blob != null) {
            return blob.getFilename();
        }

        return space.resolveFilename(blobKey).orElse(blobKey);
    }

    private String determineEffectiveFilename() {
        String effectiveFileName = determineFilename();
        String effectiveFileExtension = determineVariantFileExtension().orElse(null);
        if (Strings.isFilled(effectiveFileExtension)) {
            return Files.getFilenameWithoutExtension(effectiveFileName) + "." + effectiveFileExtension;
        } else {
            return effectiveFileName;
        }
    }

    private Optional<String> determineVariantFileExtension() {
        return Value.of(variant)
                    .ignore(VARIANT_RAW)
                    .asOptionalString()
                    .map(conversionEngine::determineTargetFileExtension);
    }

    private String fetchUrlEncodedFileExtension() {
        String result = determineVariantFileExtension().orElseGet(() -> Files.getFileExtension(determineFilename()));

        if (Strings.isFilled(result)) {
            return "." + Urls.encode(result);
        } else {
            return "";
        }
    }
}
