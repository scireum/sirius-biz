/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.biz.storage.layer2;

import io.netty.handler.codec.http.HttpResponseStatus;
import sirius.biz.storage.util.StorageUtils;
import sirius.kernel.commons.Strings;
import sirius.kernel.di.GlobalContext;
import sirius.kernel.di.std.Part;
import sirius.kernel.di.std.Register;
import sirius.kernel.health.Exceptions;
import sirius.web.http.Response;
import sirius.web.http.WebContext;
import sirius.web.http.WebDispatcher;

import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Optional;

/**
 * Responsible for delivering {@link Blob blobs} managed by the {@link BlobStorage Layer 2} of the storage framework.
 * <p>
 * This will mainly deliver blobs via URLs generated by {@link URLBuilder}. As this is a central activity (doesn't
 * need any user authentication (URLs are pre-signed) and its responsibility can be checked easily (all requests URIs
 * start with a common {@link BlobDispatcher#URI_PREFIX})) this has a pretty low priority. Note that
 * {@link URLBuilder#enableLargeFileDetection()} can be used so that URLs pointing to large files always start with
 * the prefix <tt>/dasd/xxl</tt>. This can be used by upstream reverse-proxies to detect files which aren't worth or
 * healthy to cache.
 * <p>
 * Note that this dispatcher itself doesn't do more than decoding and verifying the URL. All the heavy lifting is
 * either done by {@link sirius.biz.storage.layer1.ObjectStorageSpace#deliver(Response, String, boolean)} for physical URLs
 * or {@link BlobStorageSpace#deliver(String, String, Response, Runnable)} for virtual URLs.
 */
@Register(framework = StorageUtils.FRAMEWORK_STORAGE)
public class BlobDispatcher implements WebDispatcher {

    /**
     * Contains the base prefix for all URIs handled by this dispatcher.
     * <p>
     * As this dispatcher is most probably active in every system we do not want to "block" a common name
     * like "storage" or the like. However, we have to pick a name after all. Therefore, we went with a rather short
     * acronym from the mainframe area (DASD stood/stands/will always stand for Direct Attached Storage Device) and
     * is nowadays simply called a hard disk. Yes, it doesn't match the purpose of the URI but its short, not a common
     * term and <b>fun</b>.
     */
    public static final String URI_PREFIX = "/dasd";

    /**
     * Contains the {@link #URI_PREFIX} with a trailing slash.
     */
    public static final String URI_PREFIX_TRAILED = URI_PREFIX + "/";

    /**
     * Contains a marker which can be placed in a URI to signal that the underlying file might be very large.
     * <p>
     * The dispatcher itself simply ignores this marker, but upstream reverse-proxies like NGINX or Varnish
     * can use this to optimize their cache utilization (e.g. by fully ignoring or piping this request/response).
     */
    public static final String LARGE_FILE_MARKER = "xxl/";

    /**
     * Marks the request as "physical" access (direct layer 1 access).
     */
    public static final String FLAG_PHYSICAL = "p";

    /**
     * Marks the request as "download".
     * <p>
     * This will invoke {@link Response#download(String)} before starting delivery.
     */
    public static final String FLAG_DOWNLOAD = "d";

    /**
     * Marks the request as "virtual" (layer 2) access.
     */
    public static final String FLAG_VIRTUAL = "v";

    /**
     * Marks the request as cacheable.
     * <p>
     * Otherwise, all HTTP cache settings would be turned off.
     */
    public static final String FLAG_CACHEABLE = "c";

    /**
     * Signalizes that the caller is ready to wait longer for a response.
     * <p>
     * This is especially used when the variant retrieved will be converted on-the-fly, and you want to increase the
     * chance of getting one without having to implement a client-side retry mechanism.
     */
    public static final String WAIT_LONGER_PARAMETER = "waitLonger";

    /**
     * Header set to signalize that the caller is ready to wait longer for a response.
     */
    public static final String HEADER_WAIT_LONGER = "X-Wait-Longer";

    private static final String PARAM_HOOK = "hook";
    private static final String PARAM_PAYLOAD = "payload";

    @Part
    private BlobStorage blobStorage;

    @Part
    private StorageUtils utils;

    @Part
    private GlobalContext globalContext;

    @Override
    public int getPriority() {
        return 10;
    }

    @Override
    public DispatchDecision dispatch(WebContext request) throws Exception {
        String uri = request.getRequestedURI();
        if (!uri.startsWith(URI_PREFIX_TRAILED)) {
            return DispatchDecision.CONTINUE;
        }

        Optional<BlobUri> blobUri = BlobUriParser.parseBlobUri(uri);

        if (blobUri.isPresent()) {
            installCompletionHook(uri, request);

            if (blobUri.get().isPhysical()) {
                physicalDelivery(request, blobUri.get());
            } else {
                virtualDelivery(request, blobUri.get());
            }

            return DispatchDecision.DONE;
        }

        return DispatchDecision.CONTINUE;
    }

    private void installCompletionHook(String uri, WebContext request) {
        request.get(PARAM_HOOK).ifFilled(hook -> {
            request.getCompletionPromise().onSuccess(code -> {
                if (code == HttpResponseStatus.OK.code()) {
                    executeHook(uri, hook.asString(), request.get(PARAM_PAYLOAD).asString());
                }
            });
        });
    }

    private void executeHook(String uri, String hook, String payload) {
        try {
            BlobDispatcherHook dispatcherHook = globalContext.getPart(hook, BlobDispatcherHook.class);
            if (dispatcherHook != null) {
                dispatcherHook.hook(payload);
            }
        } catch (Exception exception) {
            Exceptions.handle()
                      .to(StorageUtils.LOG)
                      .withSystemErrorMessage(
                              "An error occurred when executing hook '%s' with payload '%s' for URI: '%s'",
                              hook,
                              payload,
                              uri)
                      .handle();
        }
    }

    /**
     * Prepares a {@link Response} and delegates the call to the layer 1.
     *
     * @param request the request to handle
     * @param blobUri the parsed blob URI
     */
    private void physicalDelivery(WebContext request, BlobUri blobUri) {
        Response response = request.respondWith().preventSearchEngineIndexing();
        Integer cacheSeconds = computeCacheDurationFromHash(blobUri.getAccessToken(),
                                                            blobUri.getPhysicalKey(),
                                                            blobUri.getStorageSpace());
        if (cacheSeconds == null) {
            response.error(HttpResponseStatus.UNAUTHORIZED);
            return;
        }
        response.cachedForSeconds(cacheSeconds);

        if (blobUri.isDownload()) {
            response.download(blobUri.getFilename());
        } else {
            response.named(blobUri.getFilename());
        }

        blobStorage.getSpace(blobUri.getStorageSpace())
                   .deliverPhysical(blobUri.getBlobKey(),
                                    blobUri.getPhysicalKey(),
                                    response,
                                    blobUri.isLargeFileExpected());
    }

    /**
     * Checks if the provided accessToken is invalid and return the cache time in seconds based on the hash validity.
     *
     * @param accessToken the security token to verify
     * @param key         the key to verify
     * @param space       the space which is accessed
     * @return the cache time in seconds or <tt>null</tt> if the hash is invalid
     */
    private Integer computeCacheDurationFromHash(String accessToken, String key, String space) {
        BlobStorageSpace storageSpace = blobStorage.getSpace(space);
        Optional<Integer> optionalHashDays = utils.verifyHash(key, accessToken, storageSpace.getUrlValidityDays());
        if (optionalHashDays.isEmpty()) {
            return null;
        }

        int hashDays = optionalHashDays.get();
        if (hashDays == Integer.MAX_VALUE) {
            // Detected a eternallyValid hash, cache indefinitely
            return Response.HTTP_CACHE_INFINITE;
        } else if (hashDays > 0) {
            // Detected a hash in the future, cache for the remaining days
            return computeCacheInSeconds(hashDays);
        } else {
            // Detected a hash in the past. Subtract the amount of days from the limit defined by the space
            return computeCacheInSeconds(storageSpace.getUrlValidityDays() + hashDays);
        }
    }

    private int computeCacheInSeconds(int days) {
        LocalTime now = LocalDateTime.now().toLocalTime();
        int secondsToMidnight = 86400 - (now.getSecond() + now.getMinute() * 60 + now.getHour() * 3600);
        if (days == 0) {
            return secondsToMidnight;
        }
        return secondsToMidnight + (days - 1) * 86400;
    }

    /**
     * Prepares a {@link Response} and delegates the call to the layer 2.
     *
     * @param request the request to handle
     * @param blobUri the parsed blob URI
     */
    private void virtualDelivery(WebContext request, BlobUri blobUri) {
        String blobKey = blobUri.getBlobKey();
        String variant = blobUri.getVariant();
        String effectiveKey = Strings.isFilled(variant) ? blobKey + "-" + variant : blobKey;

        Response response = request.respondWith().preventSearchEngineIndexing();
        Integer cacheSeconds =
                computeCacheDurationFromHash(blobUri.getAccessToken(), effectiveKey, blobUri.getStorageSpace());
        if (cacheSeconds == null) {
            response.error(HttpResponseStatus.UNAUTHORIZED);
            return;
        }

        if (blobUri.isCacheable()) {
            // Limit the cache time to a maximum of 1 hour for all virtual URLs, since it does not make sense to cache
            // those for long as the underlying file might change.
            response.cachedForSeconds(Math.min(cacheSeconds, 3600));
        } else {
            response.notCached();
        }

        // Check if we have an actual file to deliver ...
        BlobStorageSpace storageSpace = blobStorage.getSpace(blobUri.getStorageSpace());
        URLBuilder.UrlResult urlResult =
                buildPhysicalRedirectUrl(storageSpace, blobUri, cacheSeconds == Response.HTTP_CACHE_INFINITE);
        if (urlResult.urlType() == URLBuilder.UrlType.PHYSICAL) {
            // ... and if so, redirect to the physical URL ...
            response.redirectTemporarily(urlResult.url());
            return;
        }

        if (urlResult.urlType() == URLBuilder.UrlType.VIRTUAL) {
            // A conversion will be attempted and tunneled over. Disable caching completely as we expect
            // subsequent requests to deliver a redirect URL the new converted physical file.
            response.notCached();
        }

        if (urlResult.urlType() == URLBuilder.UrlType.EMPTY) {
            response.error(HttpResponseStatus.NOT_FOUND);
            return;
        }

        String filename = blobUri.getFilename();

        if (blobUri.isDownload()) {
            if (Strings.areEqual(filename, blobKey)) {
                filename = storageSpace.resolveFilename(blobKey).orElse(filename);
            }
            response.download(filename);
        } else {
            response.named(filename);
        }

        if (request.get(WAIT_LONGER_PARAMETER).asBoolean()) {
            response.addHeader(HEADER_WAIT_LONGER, true);
        }

        storageSpace.deliver(blobKey,
                             variant != null ? variant : URLBuilder.VARIANT_RAW,
                             response,
                             request::markAsLongCall);
    }

    private static URLBuilder.UrlResult buildPhysicalRedirectUrl(BlobStorageSpace storageSpace,
                                                                 BlobUri blobUri,
                                                                 boolean eternallyValid) {
        URLBuilder urlBuilder = new URLBuilder(storageSpace, blobUri.getBlobKey());

        if (eternallyValid) {
            urlBuilder.eternallyValid();
        }
        if (blobUri.isDownload()) {
            urlBuilder.withFileName(blobUri.getFilename()).asDownload();
        }
        if (Strings.isFilled(blobUri.getVariant())) {
            urlBuilder.withVariant(blobUri.getVariant());
        }
        if (blobUri.isLargeFileExpected()) {
            urlBuilder.markAsLargeFile();
        }

        try {
            return urlBuilder.buildUrlResult();
        } catch (Exception exception) {
            // Conversion ultimately failed. The error has already been logged during conversion, all we need is to
            // return an empty result so that a 404 is returned to the caller.
            Exceptions.ignore(exception);
            return new URLBuilder.UrlResult(null, URLBuilder.UrlType.EMPTY);
        }
    }
}
